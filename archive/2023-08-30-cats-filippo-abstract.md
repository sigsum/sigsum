Title: **What we need next: an interoperable witness ecosystem**

Speaker: Filippo Valsorda (attending in person)

Filippo is a cryptography engineer and open source maintainer. He co-designed the Go Checksum Database, and works on the Sigsum design. He’s been a maintainer of the Go cryptography standard library since 2018, first at Google while lead of the Go Security team, and now as a professional, full-time, independent maintainer. He contributed to the design of TLS 1.3 and implemented it for the Cloudflare beta deployment and for the Go project. He’s also the author of some popular Go tools including the file encryption tool age, and mkcert, a tool to produce locally-trusted certificates.

## Abstract

Transparency is successfully deployed, bringing to data the accountability that open source brings to software: we have the Go Checksum Database instead of an opaque registry of Go modules, key transparency instead of pretending anyone compares fingerprints, and checksum logs for software releases instead of whatever the GitHub API returns. By and large, though, these deployments ~~handwave~~ leave as future work split view detection. What we have is not worth nothing: introducing even the theoretical risk of cryprographically-provable detection, with the log operator staking all their reputation on that not happening, significantly deters attacks. However, there are settings in which an attacker with control of a log can reasonably assume a split will go undetected: imagine targeting an ephemeral CI machine that builds a binary and is then completely wiped, destroying any evidence of a malicious log split. If everything standing between accountability and unconditional trust in the log operator is the Merkle tree consistency, that deployment is not getting a lot of value.

The solutions to split views fall broadly in three buckets: client side consistency, gossiping, and witness cosigning. Client side consistency is the idea that an attacker might fail over time to systematically present a consistent split view to the target, for example because they are a developer moving across WiFi and mobile data. Gossiping is the idea that the client will, at some time after accepting the transparency proof, compare their tree with other clients or with monitors. Witnessing is the idea that proofs need to come cosigned by other parties that attest that they saw proof that the tree presented to the client is consistent with any other view of the tree they witnessed.

Client side consistency and gossiping have two fatal flaws. First, they are abstraction-breaking: while we’d like proofs to be offline-verifiable self-contained statements like the digital signatures they are replacing, they both require client-side storage, and gossiping even requires (privacy-preserving!) network connectivity. Second, they are defeated by the consequences of a successful split-view attack in unsandboxed scenarios, the very thing they should protect against. Imagine for example a transparency log that’s providing accountability for a package manager that—like most package managers unfortunately—supports install-time hooks. An attacker that controls a log and forges a split-view proof can include a post-install hook that replaces the stored split-view tree head on disk with an innocent, consistent tree head, defeating both any future consistency check and any gossiping attempt.

Witnesses, instead, can provide assurance at proof verification time, with flexible offline M-of-N policies. However, for witness deployment to be trustworthy and available, we need witnesses to be operated by entities that have a reputation to stake, and that can be relied upon for long-term operation. In this talk we’ll look at the requirements of witnesses, and discuss why for the witness ecosystem to serve a diverse set of transparency deployments, including low-latency logs (such as the Go Checksum Database) and “offline” batch-produced logs (such as certain package management registries), we need witnesses to be synchronously and publicly addressable. We'll look at solutions and tradeoffs to make witnesses technically easy to operate without compromising their utility, such as reverse proxying "bastion" hosts. We'll present the interoperable checkpoint format adopted by the Sigsum and Omniwitness projects. Finally, we’ll discuss the remaining risk of split-view attacks through witness population partitioning, and how that requires monitors (but not clients) to keep connectivity to a sufficient number of witnesses. Building an ecosystem of high-quality, trustworthy, long-term witnesses will be hard, but will serve to solve the split-view issue for any transparency deployment in the future, lowering the cost of deploying new logs and making them accessible as a solution in many settings that can’t get with trust where accountability can.
